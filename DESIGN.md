# Token Bridge Relayer

## Objective

Create an example contract that utilizes Wormhole’s Token Bridge to send cross-chain transfers with native asset drop-off.

## Background

The Token Bridge Relayer allows users to send select assets (`acceptedTokens`) cross chain by composing on the Token Bridge’s contract-controlled transfer protocol. Currently, sending tokens cross chain (and actually being able to utilize those tokens) is a multi-step process:

1. Invoke the Token Bridge contract
2. Fetch the signed transfer message (VAA) from the Guardian network
3. Invoke the Token Bridge contract on the target chain to mint wrapped assets (or unwrap native assets)
4. Source the native asset (gas) on the target chain in order to utilize the bridged funds

With the Token Bridge Relayer contract, users can achieve the same end result by interacting with a single smart contract on the origin chain.

## Detailed Design (Based on EVM Interface)

To initiate a transfer, a user will invoke the `transferTokensWithRelay` method on the `TokenBridgeRelayer` contract. The `transferTokensWithRelay` method takes six arguments:

- `token` - Address of the token on the origin chain
- `amount` - Amount of tokens to be transferred
- `toNativeTokenAmount` - Amount of tokens to swap into native assets on the target chain
- `targetChain` - Wormhole chain ID of the target chain
- `targetRecipient` - User’s wallet address on the target chain (32-byte representation)
- `batchId` - Wormhole message nonce

`transferTokensWithRelay` takes custody of the user’s tokens and calls Wormhole’s Token Bridge contract to initiate a contract-controlled transfer. The contract-controlled transfer allows the `TokenBridgeRelayer` contract to send an arbitrary payload (see the `Payloads` section of this design) containing instructions on how to pay the off-chain relayer and the quantity of transferred tokens to convert into native assets on the target chain.

Once the user initiates a relayable transfer (i.e. user submits transaction) the off-chain relayer will fetch the attested Wormhole message (VAA) and parse the `TransferWithRelay` payload to determine the destination and the quantity of tokens the user has selected to swap with the target `TokenBridgeRelayer` contract. Then the off-chain relayer will call `calculateNativeSwapAmountOut` on the target `TokenBridgeRelayer` contract (passing the user-selected token quantity as an argument) to determine the quantity of native assets to pass to the contract when completing the transfer. To determine the exchange rate between the native asset and the token being transferred, the `owner` or `ownerAssistant` of the contract will set the `swapRate` for each `acceptedToken`.

To complete the transfer, the off-chain relayer invokes the `completeTransferWithRelay` method on the target `TokenBridgeRelayer` contract, passing the attested Wormhole message (and predetermined native asset value) to the contract. The `TokenBridgeRelayer` contract then completes the following actions:

1. Determines if the token being transferred is an `acceptedToken`
2. Completes the transfer (and verifies the VAA) by invoking the Wormhole Token Bridge contract
3. Takes custody of the newly minted (or released) tokens
4. Verifies that the Wormhole message was generated by a `registeredContract`
5. Parses the `TransferWithRelay` payload
6. Determines if the user requested a swap amount larger than the `maxNativeSwapAmount`
7. Determines if the relayer sent enough native assets to perform a swap (if requested by the user)
8. Sends the remaining tokens (and native assets) to the recipient
9. Sends swap proceeds to the off-chain relayer, and refunds any excess native assets
10. Pays the off-chain relayer a fee for facilitating the transfer and swap

## Solana Design

Given Solana's architecture, the design for the `TokenBridgeRelayer` smart contract is slightly different when compared with the Sui and EVM contracts.

#### Native Swaps

Solana does not allow the transaction `payer` (the off-chain relayer) to specify an amount of lamports (native asset) to pass to the contract during execution. To bypass this, the Solana `TokenBridgeRelayer` contract directly transfers lamports from the `payer` to the `recipient` when performing a native asset swap. This does change the trust assumptions between the off-chain relayer and the Solana contract, since the contract directly determines how many lamports to deduct from the off-chain relayer's account. However, the Solana contract will never deduct more than the `max_native_swap_amount`.

#### Relayer Fees for SOL Transfers

Instead of paying the `fee_recipient` a `relayer_fee` when completing a transfer for native SOL, the `payer` will receive the `relayer_fee`. The Wormhole Token Bridge releases WSOL when completing a native transfer on Solana, which is not the desired asset for users. Instead, this contract unwraps the WSOL by closing the WSOL account and transfers the lamports to the `payer`. The contract then transfers the intended amount of lamports from the `payer` account to the `recipient` account. This design reduces the need for a temporary system account for warehousing the SOL after closing the WSOL account. It also doesn't require the `fee_recipient` to sign the transaction.

#### Native vs. Wrapped

There are separate instruction handlers for handling inbound and outbound transfers of native (tokens created on Solana) and wrapped (Wormhole-wrapped) tokens.

## Future Considerations

The `TokenBridgeRelayer` contracts currently rely on a centralized actor (the `owner` or `ownerAssistant`) to update the swap rates between native assets and Token Bridge supported assets. Integrating with a decentralized oracle such as [Pyth](https://github.com/pyth-network/pyth-sdk-solidity) would greatly enhance the user experience and security of these contracts.

## API

### EVM

```solidity
function transferTokensWithRelay(
    address token,
    uint256 amount,
    uint256 toNativeTokenAmount,
    uint16 targetChain,
    bytes32 targetRecipient,
    uint32 batchId
) external payable returns (uint64 messageSequence);

function wrapAndTransferEthWithRelay(
    uint256 toNativeTokenAmount,
    uint16 targetChain,
    bytes32 targetRecipient,
    uint32 batchId
) external payable returns (uint64 messageSequence);

function completeTransferWithRelay(bytes calldata encodedTransferMessage) external payable;

function calculateMaxSwapAmountIn(address token) external view returns (uint256);

function calculateNativeSwapAmountOut(address token, uint256 toNativeAmount) external view returns (uint256);
```

### Solana

```rust
pub fn transfer_native_tokens_with_relay(
    ctx: Context<TransferNativeWithRelay>,
    amount: u64,
    to_native_token_amount: u64,
    recipient_chain: u16,
    recipient_address: [u8; 32],
    batch_id: u32,
    wrap_native: bool,
);

pub fn transfer_wrapped_tokens_with_relay(
    ctx: Context<TransferWrappedWithRelay>,
    amount: u64,
    to_native_token_amount: u64,
    recipient_chain: u16,
    recipient_address: [u8; 32],
    batch_id: u32,
);

pub fn complete_native_transfer_with_relay(
    ctx: Context<CompleteNativeWithRelay>,
    _vaa_hash: [u8; 32],
);

pub fn complete_wrapped_transfer_with_relay(
    ctx: Context<CompleteWrappedWithRelay>,
    _vaa_hash: [u8; 32],
);
```

## Payload

```solidity
struct TransferWithRelay {
    uint8 payloadId; // == 1
    uint256 targetRelayerFee;
    uint256 toNativeTokenAmount;
    bytes32 targetRecipient;
}
```
