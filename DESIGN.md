# Token Bridge Relayer

## Objective

Create an example contract that utilizes Wormhole’s Token Bridge to send cross-chain transfers with native asset drop-off.

## Background

The Token Bridge Relayer allows users to send select assets (`acceptedTokens`) cross chain by composing on the Token Bridge’s contract-controlled transfer protocol. Currently, sending tokens cross chain (and actually being able to utilize those tokens) is a multi-step process:

1. Invoke the Token Bridge contract
2. Fetch the signed transfer message (VAA) from the Guardian network
3. Invoke the Token Bridge contract on the target chain to mint wrapped assets (or unwrap native assets)
4. Source the native asset (gas) on the target chain in order to utilize the bridged funds

With the Token Bridge Relayer contract, users can achieve the same end result by interacting with a single smart contract on the origin chain.

## Detailed Design (Based on EVM Interface)

To initiate a transfer, a user will invoke the `transferTokensWithRelay` method on the `TokenBridgeRelayer` contract. The `transferTokensWithRelay` method takes six arguments:

- `token` - Address of the token on the origin chain
- `amount` - Amount of tokens to be transferred
- `toNativeTokenAmount` - Amount of tokens to swap into native assets on the target chain
- `targetChain` - Wormhole chain ID of the target chain
- `targetRecipient` - User’s wallet address on the target chain (32-byte representation)
- `batchId` - Wormhole message nonce

`transferTokensWithRelay` takes custody of the user’s tokens and calls Wormhole’s Token Bridge contract to initiate a contract-controlled transfer. The contract-controlled transfer allows the `TokenBridgeRelayer` contract to send an arbitrary payload (see the `Payloads` section of this design) containing instructions on how to pay the off-chain relayer and the quantity of transferred tokens to convert into native assets on the target chain.

Once the user initiates a relayable transfer (i.e. user submits transaction) the off-chain relayer will fetch the attested Wormhole message (VAA) and parse the `TransferWithRelay` payload to determine the destination and the quantity of tokens the user has selected to swap with the target `TokenBridgeRelayer` contract. Then the off-chain relayer will call `calculateNativeSwapAmountOut` on the target `TokenBridgeRelayer` contract (passing the user-selected token quantity as an argument) to determine the quantity of native assets to pass to the contract when completing the transfer. To determine the exchange rate between the native asset and the token being transferred, the `owner` or `ownerAssistant` of the contract will set the `swapRate` for each `acceptedToken`.

To complete the transfer, the off-chain relayer invokes the `completeTransferWithRelay` method on the target `TokenBridgeRelayer` contract, passing the attested Wormhole message (and predetermined native asset value) to the contract. The `TokenBridgeRelayer` contract then completes the following actions:

1. Determines if the token being transferred is an `acceptedToken`
2. Completes the transfer (and verifies the VAA) by invoking the Wormhole Token Bridge contract
3. Takes custody of the newly minted (or released) tokens
4. Verifies that the Wormhole message was generated by a `registeredContract`
5. Parses the `TransferWithRelay` payload
6. Determines if the user requested a swap amount larger than the `maxNativeSwapAmount`
7. Determines if the relayer sent enough native assets to perform a swap (if requested by the user)
8. Sends the remaining tokens (and native assets) to the recipient
9. Sends swap proceeds to the off-chain relayer, and refunds any excess native assets

## Future Considerations

The `TokenBridgeRelayer` contracts currently rely on a centralized actor (the `owner` or `ownerAssistant`) to update the swap rates between native assets and Token Bridge supported assets. Integrating with a decentralized oracle such as [Pyth](https://github.com/pyth-network/pyth-sdk-solidity) would greatly enhance the user experience and security of these contracts.

## API

### EVM

```solidity
function transferTokensWithRelay(
    address token,
    uint256 amount,
    uint256 toNativeTokenAmount,
    uint16 targetChain,
    bytes32 targetRecipient,
    uint32 batchId
) external payable returns (uint64 messageSequence);

function wrapAndTransferEthWithRelay(
    uint256 toNativeTokenAmount,
    uint16 targetChain,
    bytes32 targetRecipient,
    uint32 batchId
) external payable returns (uint64 messageSequence);

function completeTransferWithRelay(bytes calldata encodedTransferMessage) external payable;

function calculateMaxSwapAmountIn(address token) external view returns (uint256);

function calculateNativeSwapAmountOut(address token, uint256 toNativeAmount) external view returns (uint256);
```

## Payload

```solidity
struct TransferWithRelay {
    uint8 payloadId; // == 1
    uint256 targetRelayerFee;
    uint256 toNativeTokenAmount;
    bytes32 targetRecipient;
}
```
